# 자바의 디자인 패턴

## *Part 01* 디자인 패턴과 친해지기
> 이해하기 쉬운 패턴

### *Chapter 01* **Iterator**
```순서대로 지정해서 처리하기```
- 복수의 요소가 모여 있는 집합에서 요소를 순서대로 지정하여 처리하는 패턴

### *Chapter 02* **Adapter**
```바꿔서 재이용하기```
- 서로 다른 인터페이스(API)를 갖는 클래스들을 연결하는 패턴

<hr>
<br>

## *Part 02* 하위 클래스에게 위임하기
> 클래스의 상속과 관련된 패턴

### *Chapter 03* **Template Method**
```하위 클래스에서 구체적으로 처리하기```
- 상위 클래스에서 처리의 뼈대를 세우고 구체적인 처리를 하위 클래스에서 실행하는 패턴

### *Chapter 04* **Factory Method**
```하위 클래스에서 인스턴스 작성하기```
- 상위 클래스에서 인스턴스 작성법의 뼈대를 세우고, 구체적인 작성은 하위 클래스에서 실행하는 패턴

<hr>
<br>

## *Part 03* 인스턴스 만들기
> 인스턴스의 작성에 관련된 패턴

### *Chapter 05* **Singleton**
```인스턴스 한 개만 만들기```
- 인스턴스가 하나만 존재하는 패턴

### *Chapter 06* **Prototype**
```복사해서 인스턴스 만들기```
- 모형이 되는 인스턴스를 복사해서 다른 인스턴스를 만드는 패턴

### *Chapter 07* **Builder**
```복잡한 인스턴스 조립하기```
- 복잡한 인스턴스를 단계적으로 조립하는 패턴

### *Chapter 08* **Abstract Factory**
```관련 부품을 조합해서 제품 만들기```
- 공장과 같이 부품을 조합해서 인스턴스 생성을 실행하는 패턴

<hr>
<br>

## *Part 04* 분리해서 생각하기
> 복잡하게 뒤섞이기 쉬운 프로그램을 분리해서 생각하는 패턴

### *Chapter 09* **Bridge**
```기능 계층과 구현 계층 분리하기```
- 두 종류의 확장이 혼재하는 프로그램을 기능과 구현의 계층으로 분리하여 그 사이를 연결하는 패턴

### *Chapter 10* **Strategy**
```알고리즘을 모두 바꾸기```
- 알고리즘을 전부 교체해서 수정하기 쉽도록 하는 패턴

<hr>
<br>

## *Part 05* 동일시하기
> 서로 다른 것을 통일적으로 조작할 수 있도록 하거나, 취급 방법을 바꾸지 않고 기능을 추가하는 패턴

### *Chapter 11* **Composite**
```그릇과 내용물을 동일시하기```
- 그릇과 내용물을 동일시해서 재귀적인 구조를 구축하는 패턴

### *Chapter 12* **Decotator**
```장식과 내용물을 동일시하기```
- 장식과 내용물을 동일시해서 장식을 여러 겹 중복되게 하는 패턴

<hr>
<br>

## *Part 06* 구조를 돌아다니기
> 데이터 구조를 돌아다니는 패턴

### *Chapter 13* **Visitor**
```데이터 구조를 돌아다니면서 처리하기```
- 데이터 구조를 돌아다니면서 동일한 조작을 반복해서 적용하는 패턴

### *Chapter 14* **Chain of Responsibility**
```책임 떠넘기기```
- 복수의 객체가 연결되어 있는 내부에서 작업을 수행하는 패턴

<hr>
<br>

## *Part 07* 단순화하기
> 클래스들이 복잡한 관계에 있을 때, 클래스를 단순하게 하는 패턴

### *Chapter 15* **Facade**
```단순한 창구```
- 복잡하게 얽힌 클래스를 하나의 창구 클래스를 배치하여 시스템 전체의 조작성을 좋게 하는 패턴

### *Chapter 16* **Mediator**
```중개인을 통해서 처리하기```
- 복수의 클래스를 중개역 클래스로만 의사 소통을 하게끔 제한하여 프로그램을 단순하게 만드는 패턴

<hr>
<br>

## *Part 08* 상태를 관리하기
> 상태에 관련된 패턴
> 
### *Chapter 17* **Observer**
```상태의 변화를 알려주기```
- 상태가 변화하는 클래스와 그 변화를 통지받는 클래스를 분리하여 생각하는 패턴

### *Chapter 18* **Memento**
```상태를 저장하기```
- 현재의 상태를 저장해두고 필요할 때 복귀시키는 undo 기능을 설정하는 패턴

### *Chapter 19* **State**
```상태를 클래스로 표현하기```
- 상태를 클래스로 표현하고 상태에 적합한 switch문의 사용을 줄여주는 패턴

<hr>
<br>

## *Part 09* 낭비 제거하기
> 낭비를 제거하여 효율적인 처리를 실행하는 패턴

### *Chapter 20* **Flyweight**
```동일한 것을 공유해서 낭비 제거하기```
- 복수의 장소에서 동일한 것이 등장할 때 공유를 통해 낭비를 제거하는 패턴

### *Chapter 21* **Proxy**
```필요해지면 생성하기```
- 목적한 것이 반드시 필요하게 될 때까지 대리인을 사용해 처리를 진행시키는 패턴

<hr>
<br>

## *Part 10* 하위 클래스에게 위임하기
> 명령, 문법규칙과 같은 의외의 것을 클래스로 표현하는 패턴

### *Chapter 22* **Command**
```명령을 클래스로 표현하기```
- 요구나 명령을 형태로 만들어서 클래스로 표현하는 패턴

### *Chapter 23* **Interpreter**
```문법규칙을 클래스로 표현하기```
- 문법규칙을 클래스로 표현하는 패턴

<hr>
<br>